syntax = "proto3";

package proto;

message Node {
  // The id of the node
  bytes id = 2;

  // The address of the node
  bytes addr = 3;
}

message Header {
  // ProtocolVerison is the version of the protocol the sender is speaking
  int32 protocol_version = 1;

  // The source node which sending the request or response
  Node from = 2;
}

message Log {
  // The index of the log entry.
  uint64 index = 1;

  // The election term of the log entry.
  uint64 term = 2;

  // The type of the log entry.
  uint32 type = 3;

  // The log entries type-specific data.
  bytes data = 4;

  // Extensions holds an opaque byte slice of information for middleware. It
  // is up to the client of the library to properly modify this as it adds
  // layers and remove those layers when appropriate. This value is a part of
  // the log, so very large values could cause timing issues.
  //
  // N.B. It is _up to the client_ to handle upgrade paths. For instance if
  // using this with go-raftchunking, the client should ensure that all Raft
  // peers are using a version that can handle that extension before ever
  // actually triggering chunking behavior. It is sometimes sufficient to
  // ensure that non-leaders are upgraded first, then the current leader is
  // upgraded, but a leader changeover during this process could lead to
  // trouble, so gating extension behavior via some flag in the client
  // program is also a good idea.
  bytes extensions = 5;

  // AppendedAt stores the time the leader first appended this log to it's
  // LogStore. Followers will observe the leader's time. It is not used for
  // coordination or as part of the replication protocol at all. It exists only
  // to provide operational information for example how many seconds worth of
  // logs are present on the leader which might impact follower's ability to
  // catch up after restoring a large snapshot. We should never rely on this
  // being in the past when appending on a follower or reading a log back since
  // the clock skew can mean a follower could see a log with a future timestamp.
  // In general too the leader is not required to persist the log before
  // delivering to followers although the current implementation happens to do
  // this.
  // Time validity bounds.
  uint64 appended_at = 6;
}

service Transport {
  rpc AppendEntries(AppendEntriesRequest) returns (AppendEntriesResponse);
  rpc AppendEntriesPipeline(stream AppendEntriesRequest) returns (stream AppendEntriesResponse);
  rpc RequestVote(RequestVoteRequest) returns (RequestVoteResponse);
  rpc InstallSnapshot(stream InstallSnapshotRequest) returns (stream InstallSnapshotResponse);
  rpc TimeoutNow(TimeoutNowRequest) returns (TimeoutNowResponse);
}

// AppendEntriesRequest is the command used to append entries to the
// replicated log.
message AppendEntriesRequest {
  
  Header header = 1;

  // Provide the current term and leader
  uint64 term = 2;

  // Provide the previous entries index for integrity checking
  uint64 previous_log_entry = 3;

  // PreviousLogTerm is the previous logs term value for integrity checking
  uint64 previous_log_term = 4;

  // New entries to commit
  repeated Log entries = 5;

  // Commit index on the leader
  uint64 leader_commit_index = 6;
}

// AppendEntriesResponse is the response returned from an
// AppendEntriesRequest.
message AppendEntriesResponse {
  Header header = 1;

  // Newer term if leader is out of date
  uint64 term = 2;

  // Last Log is a hint to help accelerate rebuilding slow nodes
  uint64 last_log = 3;

  // We may not succeed if we have a conflicting entry
  bool success = 4;

  // There are scenarios where this request didn't succeed
  // but there's no need to wait/back-off the next attempt.
  bool no_retry_backoff = 5;
}

// RequestVoteRequest is the command used to request a vote.
message RequestVoteRequest {
  Header header = 1;

  // Provide the term
  uint64 term = 2;

  // The requesting servers last log index
  uint64 last_log_index = 3;

  // The requesting servers last log term
  uint64 last_log_term = 4;

  // Used to indicate to peers if this vote was triggered by a leadership
  // transfer. It is required for leadership transfer to work, because servers
  // wouldn't vote otherwise if they are aware of an existing leader.
  bool leadership_transfer = 5;
}

// RequestVoteResponse is the data returned from RequestVote RPC
message RequestVoteResponse {
  Header header = 1;

  // Provide the term
  uint64 term = 2;

  // Was the vote granted
  bool granted = 3;
}

message InstallSnapshotRequest {
  oneof message {
    InstallSnapshotMetadata metadata = 1;
    InstallSnapshotChunk chunk = 2;
  }
}

// InstallSnapshotMetadata is the initial install snapshot request
// arguments. This will be the first message sent in the InstallSnapshot RPC.
message InstallSnapshotMetadata {
  Header header = 1;

  int32 snapshot_version = 2;

  // The current term of the leader
  uint64 term = 3;

  // The last log index represented in the snapshot
  uint64 last_log_index = 4;

  // The last log term represented in the snapshot
  uint64 last_log_term = 5;

  // Contains cluster membership information.
  bytes membership = 6;

  // The log index where the Membership data was
  // originally written.
  uint64 membership_index = 7;

  // Size is the number of bytes of snapshot data to be sent.
  int64 size = 8;
}

message InstallSnapshotChunk {
  bytes data = 1;
}

// InstallSnapshotResponse is the data returned from RequestVote RPC
message InstallSnapshotResponse {
  Header header = 1;

  // Provide the term
  uint64 term = 2;

  // Success represents whether the snapshot was installed successfully.
  bool success = 3;
}

// TimeoutNowRequest is the arguments for the TimeoutNow RPC request
message TimeoutNowRequest {
  Header header = 1;
}

// TimeoutNowResponse is the response message for a TimeoutNow RPC request
message TimeoutNowResponse {
  Header header = 1;
}

message HeartbeatRequest {
  Header header = 1;
}

message HeartbeatResponse {
  Header header = 1;
}